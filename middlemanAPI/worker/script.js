!(function (e) { const t = {}; function r (n) { if (t[n]) return t[n].exports; const o = t[n] = { i: n, l: !1, exports: {} }; return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports }r.m = e, r.c = t, r.d = function (e, t, n) { r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n }) }, r.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }) }, r.t = function (e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const n = Object.create(null); if (r.r(n), Object.defineProperty(n, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const o in e)r.d(n, o, function (t) { return e[t] }.bind(null, o)); return n }, r.n = function (e) { const t = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(t, 'a', t), t }, r.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, r.p = '', r(r.s = 0) }([function (e, t) { { const e = !0; const t = [['USEAGE', `https://api.weatherbit.io/v2.0/subscription/usage?key=${WB_KEY}&`], ['CURRENT', `https://api.weatherbit.io/v2.0/current?key=${WB_KEY}&`], ['DAILY', `https://api.weatherbit.io/v2.0/forecast/daily?key=${WB_KEY}&days=16&`]]; const n = ['https://bnjmnrsh-projs.github.io']; const o = { headers: { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': 'GET', 'Access-Control-Allow-Headers': '*', 'Cache-Control': 'public', Expires: '' + -1, 'content-type': 'application/json;charset=UTF-8' }, cf: { cacheTtl: '' + -1, cacheEverything: '' + !0 } }; async function r (r) { const s = r.request; if (!1 === e && !n.includes(s.headers.get('origin'))) return console.log(s.headers.get('origin')), new Response('Requests are not allowed from this domain.', { status: 403.503, statusText: 'Not a whitelisted domain.' }); new Headers(o.headers); const { searchParams: i } = new URL(s.url); if (i.get('DEV')) { return console.log('DEV mode'), new Response(JSON.stringify(getDummyResponse()), o) } { const e = await Promise.all(t.map(function (e, t) { return fetch(e[1] + i.toString(), o).then(e => e).catch(function (e) { console.error('aResponses error', e) }) })); const r = await Promise.all(e.map(e => (async function (e) { const { headers: t } = e; const r = t.get('content-type') || ''; const n = await e.status; const s = await e.statusText; const i = await e.url.split('?')[0]; return r.includes('application/json') ? JSON.stringify(await e.json()) : JSON.stringify({ error: `HTTP status: ${n} ${s}: URL: ${i}` }, o) }(e)))); const n = function () { const e = {}; return r.map((r, n) => { try { JSON.parse(r) } catch (r) { return console.error('fCollated error', r), e[t[n][0]] = { error: 'Error collating: ' + r } }e[t[n][0]] = JSON.parse(r) }), e }; return new Response(JSON.stringify(n()), o) } }addEventListener('fetch', e => e.respondWith(r(e))) } }]))
